---
description: 
globs: 
alwaysApply: false
---
# Implementation Plan: Production Deployment

**Goal:** Deploy the current version of the LLM Expense Splitting Application to both local development and Vercel production environments. This plan focuses on achieving a stable deployment of the application in its *current state*. Comprehensive bug fixing, product improvements, and extensive performance optimization will be addressed in subsequent implementation plans after this initial deployment and further user testing.

## Implementation Context

### User & Functional Perspective
- **Problem Solved:** Enable live testing and user access to the expense splitting application with production-grade reliability and monitoring for its current feature set.
- **Key Workflows:** Automated deployment from git pushes, environment-specific configuration management, essential performance monitoring, and error tracking for deployment stability.
- **Core Capabilities:** Local development environment, staging deployment, production deployment with essential monitoring for the current application version, automated CI/CD pipeline, and foundational error tracking.

### Technical Implementation
- **Architecture Fit:** Builds upon the existing completed application with production infrastructure, monitoring, and deployment automation.
- **Affected Components:** Environment configuration, database setup, Edge Functions deployment, frontend deployment, monitoring integration.
- **Infrastructure:** Vercel for frontend/API routes, Supabase for database/Edge Functions, Sentry for error monitoring, GitHub Actions for CI/CD.

### Boundaries & Constraints
- **Out of Scope:** Feature changes to the application code beyond what is already implemented, major architectural modifications beyond what is necessary for deployment, enterprise-scale infrastructure, comprehensive bug fixing of all known issues beyond deployment blockers, and implementation of new product improvements. These will be handled in subsequent plans.
- **Limitations:** Prototype scale (<1000 users), free/starter tiers for monitoring services, standard security policies. The immediate focus is on a functional deployment of the *current version* rather than exhaustive feature parity with a theoretically complete product.
- **Unchanged Functionality:** All existing application features and user workflows remain identical.

## Relevant Files

- `.env.local` - **NEW** - Local development environment variables
- `.env.example` - **NEW** - Template for environment variable setup
- `vercel.json` - **NEW** - Vercel deployment configuration
- `.github/workflows/deploy.yml` - **NEW** - CI/CD pipeline configuration
- `next.config.ts` - **MODIFY** - Add Sentry and performance monitoring configuration
- `app_code/src/lib/monitoring/sentry.ts` - **NEW** - Sentry error tracking configuration
- `app_code/src/lib/monitoring/analytics.ts` - **MODIFY** - Enhanced analytics with production tracking
- `supabase/config.toml` - **MODIFY** - Production environment configuration
- `README.md` - **MODIFY** - Add deployment and setup instructions
- `package.json` - **MODIFY** - Add deployment scripts and monitoring dependencies

## Core Documents Affected

- `architecture.mdc` - Update with production deployment architecture and monitoring patterns (Step 2)
- `tech-stack.mdc` - Add deployment tools, monitoring services, and CI/CD tooling (Step 1)
- `design.mdc` - No changes needed for deployment

## Success Metrics
- **Deployment Success**: Both local and production environments fully functional with the current application codebase.
- **Basic Operational Stability**: Deployed application is stable and core workflows (e.g., user registration, group creation, expense logging, settlement calculation) are operational as per their current implementation.
- **Essential Monitoring Coverage**: Basic error capture and performance metrics tracking active to ensure deployment stability and identify critical post-deployment issues.
- **Uptime**: Target 99% availability for the initial production deployment.
- **Security**: All environment variables secured, RLS policies active for core data protection.
- **CI/CD**: Automated deployments working with <10 minute deploy time for the current codebase.

## Step 0: Test Scaffolding and Verification
*   **Goal:** Verify the current application state and create deployment verification tests.
*   **Actions:**
    1.  **Current State Verification:** Run full test suite to confirm 47/47 tests passing
    2.  **Build Verification:** Ensure production build succeeds without errors
    3.  **Environment Test Stubs:** Create deployment verification tests in `src/lib/__tests__/deployment.test.ts`:
        *   `test_local_environment_variables_loaded()`
        *   `test_production_build_succeeds()`
        *   `test_database_connectivity_local()`
        *   `test_database_connectivity_production()`
        *   `test_edge_functions_accessible()`
        *   `test_monitoring_integration_active()`
        *   `test_error_tracking_functional()`
*   **Validation:**
    *   All existing tests pass (47/47)
    *   Production build completes successfully
    *   New deployment test stubs are failing (as expected)
*   **Risks:**
    *   Recent changes might have introduced regressions not caught by existing tests
    *   Build configuration might have environment-specific issues
*   **Core Document Updates:** None for this step.
*   **Progress:** ✅ Completed

## Step 1: Development Environment Setup and Service Account Creation
*   **Goal:** Set up local development environment, create required service accounts, and configure deployment tooling.
*   **Actions:**
    1.  **Create Environment Template:** Create `.env.example` with all required variables documented
    2.  **Local Environment Setup:** Create `.env.local` with development configuration:
        *   Supabase URL and keys (existing)
        *   OpenAI API key (existing)
        *   Local app URL and development flags
    3.  **Service Account Creation:**
        *   Create Vercel account at https://vercel.com
        *   Set up Sentry account at https://sentry.io (free tier)
        *   Generate Vercel API token for CI/CD
        *   Create Sentry project and get DSN
    4.  **Install Deployment Tools:**
        *   Install Vercel CLI: `npm i -g vercel`
        *   Add Sentry dependencies: `@sentry/nextjs`, `@sentry/integrations`
        *   Add deployment scripts to package.json
    5.  **Test:** Create unit test for environment variable loading and service connectivity
*   **Validation:**
    *   `.env.example` template created with comprehensive documentation
    *   Local environment variables properly loaded and functional
    *   All service accounts created and accessible
    *   Deployment tools installed and authenticated
    *   Environment loading test passes
*   **Risks:**
    *   Vercel account creation might require payment method for production features
    *   Sentry free tier limits might be insufficient for prototype usage
    *   Environment variable exposure in CI/CD configuration
*   **Core Document Updates:** `tech-stack.mdc` (add Vercel, Sentry, deployment tooling).
*   **Progress:** ✅ Completed

## Step 2: Production Database and Edge Functions Setup
*   **Goal:** Configure Supabase for production use, deploy Edge Functions, and set up database optimizations.
*   **Actions:**
    1.  **Production Database Configuration:**
        *   Create production Supabase project (separate from development)
        *   Apply all database migrations to production
        *   Configure RLS policies for production security
        *   Create database indexes for performance optimization
    2.  **Edge Functions Deployment:**
        *   Deploy `parse-expense` function to production Supabase
        *   Deploy `calculate-settlement` function to production Supabase
        *   Configure environment variables for Edge Functions (OpenAI API key)
        *   Test Edge Functions in production environment
    3.  **Database Performance Optimization:**
        *   Create performance indexes as specified in DEPLOYMENT.md
        *   Configure connection pooling settings
        *   Set up database monitoring and alerting
    4.  **Security Configuration:**
        *   Verify RLS policies are active and correct
        *   Configure CORS settings for production domain
        *   Set up API rate limiting for Edge Functions
    5.  **Test:** Update deployment tests to verify production database connectivity and Edge Function accessibility
*   **Validation:**
    *   Production Supabase project configured and migrations applied
    *   Both Edge Functions deployed and responsive in production
    *   Database performance indexes created and active
    *   RLS policies verified and securing data appropriately
    *   Production database connectivity test passes
*   **Risks:**
    *   Production database setup might expose sensitive data if RLS policies are misconfigured
    *   Edge Function deployment might fail due to dependency issues or environment mismatches
    *   Database performance might degrade if indexes are not properly optimized
*   **Core Document Updates:** `architecture.mdc` (document production database architecture and Edge Function deployment patterns).
*   **Progress:** ✅ Completed (RLS issue resolved - group creation now working with secure policies)

## Step 3: Monitoring and Error Tracking Integration
*   **Goal:** Integrate Sentry error tracking, set up performance monitoring, and configure analytics for production use.
*   **Actions:**
    1.  **Sentry Integration:**
        *   Configure Sentry in `next.config.ts` with DSN and environment settings
        *   Create `src/lib/monitoring/sentry.ts` with error boundary and performance tracking
        *   Add Sentry middleware for API route error capture
        *   Configure user context and custom error tags
    2.  **Enhanced Performance Monitoring:**
        *   Update `src/lib/monitoring/performance.ts` with production metrics
        *   Add Vercel Analytics integration
        *   Configure Core Web Vitals tracking
        *   Set up custom performance alerts and thresholds
    3.  **Analytics Enhancement:**
        *   Update `src/lib/monitoring/analytics.ts` with production event tracking
        *   Add user journey tracking for key workflows
        *   Configure success metrics collection (expense logging, correction rates)
        *   Set up dashboard for real-time metrics viewing
    4.  **Error Boundaries:**
        *   Add React Error Boundaries for component-level error capture
        *   Configure fallback UI components for error states
        *   Integrate with Sentry for automatic error reporting
    5.  **Test:** Create tests for error tracking, performance monitoring, and analytics integration
*   **Validation:**
    *   Sentry capturing and reporting errors correctly
    *   Performance metrics being tracked and reported
    *   Analytics events being captured for user actions
    *   Error boundaries functioning with proper fallback UI
    *   Monitoring integration tests passing
*   **Risks:**
    *   Sentry integration might impact application performance if not configured properly
    *   Over-aggressive error tracking could capture sensitive user data
    *   Performance monitoring overhead might affect user experience
*   **Core Document Updates:** `architecture.mdc` (add monitoring and error tracking architecture), `tech-stack.mdc` (document monitoring tools and configuration).
*   **Progress:** ✅ Completed

## Step 4: Vercel Deployment Configuration
*   **Goal:** Configure Vercel deployment settings, environment variables, and custom domain setup.
*   **Actions:**
    1.  **Vercel Configuration:**
        *   Create `vercel.json` with build settings, redirects, and environment configuration
        *   Configure build commands and output directory settings
        *   Set up custom headers for security and performance
        *   Configure serverless function settings for API routes
    2.  **Environment Variable Configuration:**
        *   Add all production environment variables to Vercel dashboard
        *   Configure environment-specific variables for staging and production
        *   Secure sensitive keys (OpenAI API, Supabase service role)
        *   Set up preview deployment environment variables
    3.  **Domain and SSL Setup:**
        *   Configure custom domain (if available) or use Vercel subdomain
        *   Verify SSL certificate generation and HTTPS enforcement
        *   Set up domain redirects and canonical URL configuration
        *   Configure CORS settings for production domain
    4.  **Performance Optimization:**
        *   Configure edge caching for static assets
        *   Set up optimal image optimization settings
        *   Configure compression and minification settings
        *   Enable Edge Functions for optimal performance
    5.  **Test:** Create deployment verification test and manual deployment test
*   **Validation:**
    *   Vercel project configured and linked to repository
    *   All environment variables properly set and secured
    *   Domain and SSL configuration working correctly
    *   Performance optimizations active and effective
    *   Manual deployment test successful
*   **Risks:**
    *   Environment variable exposure during deployment process
    *   Domain configuration issues causing accessibility problems
    *   Performance optimization settings causing compatibility issues
*   **Core Document Updates:** `tech-stack.mdc` (document Vercel configuration and optimization settings).
*   **Progress:** ✅ Completed

## Step 5: CI/CD Pipeline Setup (GitHub Actions)
*   **Goal:** Automate deployments of the *current application state* to Vercel using GitHub Actions for pushes to main (production) and develop (staging) branches.
*   **Actions:**
    1.  **Workflow Creation:** Create `.github/workflows/deploy.yml`
        *   Define triggers for `main` and `develop` branches.
        *   Set up jobs for building and deploying the current application to Vercel.
        *   Use Vercel CLI for deployments.
    2.  **Secret Configuration:**
        *   Add `VERCEL_TOKEN` and `VERCEL_PROJECT_ID` to GitHub repository secrets.
        *   Add Supabase and OpenAI production keys to Vercel environment variables (via dashboard, not in repo).
    3.  **Environment-Specific Deployment:**
        *   Configure `deploy.yml` to deploy `main` branch to production Vercel project.
        *   Configure `deploy.yml` to deploy `develop` branch to a staging/preview Vercel project/alias.
    4.  **Build and Test:**
        *   Ensure the CI pipeline runs essential checks (linting, critical tests relevant to deployment) before deployment.
        *   Verify build process for the current codebase within GitHub Actions.
    5.  **Test:** Trigger deployment via push to `develop` and `main` branches.
*   **Validation:**
    *   `deploy.yml` workflow created and functional for deploying the current application version.
    *   Secrets correctly configured and accessible by the workflow.
    *   Deployments to staging and production environments successful via CI/CD.
    *   CI pipeline includes basic checks before deployment.
*   **Risks:**
    *   CI/CD pipeline misconfiguration could lead to failed deployments or deploying broken code.
    *   Incorrect secret handling could expose sensitive information.
    *   Branching strategy mismatches could lead to incorrect versions being deployed.
*   **Core Document Updates:** `architecture.mdc` (document CI/CD pipeline).
*   **Progress:** ✅ Completed (Initial pipeline structure set up, manual secret configuration and first deployment test pending by user)

## Step 6: Final Deployment Verification and Documentation
*   **Goal:** Perform final checks on the production deployment of the *current application state* and update documentation for accessing the deployed application. Extensive feature testing is deferred.
*   **Actions:**
    1.  **Production Smoke Test (Current Features):**
        *   Manually verify core application workflows *as they currently exist* in the production environment (user signup, login, group creation, expense adding, settlement viewing).
        *   Check browser console for critical errors related to deployment or core functionality.
        *   Confirm environment variables are correctly loaded in production.
    2.  **Monitoring Check:**
        *   Verify Sentry is capturing any critical errors from the smoke test.
        *   Check Vercel Analytics for initial traffic and basic performance data.
    3.  **Documentation Update (Deployment Focus):**
        *   Update `README.md` with links to the deployed production application.
        *   Add basic instructions for accessing and using the deployed application's current features.
        *   Document any known critical issues or major gaps in the *current deployed version* that users might encounter, with a note that these will be addressed in subsequent improvement cycles.
    4.  **Handover/Announcement:**
        *   Announce availability of the deployed application to relevant stakeholders, clarifying its current state and the plan for future improvements.
*   **Validation:**
    *   Core application workflows (current version) are functional in production.
    *   Essential monitoring tools are active and capturing data.
    *   `README.md` updated with correct deployment information for the current version.
*   **Risks:**
    *   Previously uncaught critical bugs in the current codebase emerge during production smoke testing, potentially blocking wider use.
    *   Deployment environment misconfiguration impacts user experience even for current features.
*   **Core Document Updates:** `README.md` (add deployment links and instructions).
*   **Progress:** ⚪ Pending

## Step 7: Post-Deployment - Prioritized Bug Fixing and Improvement Planning
*   **Goal:** Gather initial feedback from the deployed *current version*, identify critical bugs from real-world usage, and plan the next iteration of development focused on bug fixing and product improvements. This step is outside the immediate scope of *this deployment plan* but outlines the immediate next actions.
*   **Actions:**
    1.  **Monitor Initial Usage:** Closely monitor Sentry and Vercel Analytics for errors and performance issues encountered by initial users of the deployed version.
    2.  **Gather Feedback:** Collect feedback from initial users on critical bugs or usability issues in the current application.
    3.  **Prioritize Issues:** Create a prioritized backlog of bugs and essential improvements based on initial deployment experiences and the state of the current application.
    4.  **Plan Next Implementation:** Develop a new implementation plan to address the prioritized backlog of bugs and critical improvements.
*   **Validation:**
    *   A prioritized list of issues, based on the deployed version, is created.
    *   A new implementation plan is drafted for the next cycle of work (bug fixing and improvements).
*   **Risks:**
    *   Overwhelming number of issues reported from the current version, making prioritization difficult.
*   **Core Document Updates:** None for this step in the current plan; new plan will be created.
*   **Progress:** ⚪ Pending (Post-Deployment)

## Step 8: Cleanup and Final Validation
*   **Goal:** Ensure deployment infrastructure is clean, optimized, and production-ready with all temporary artifacts removed.
*   **Actions:**
    1.  **Infrastructure Cleanup:**
        *   Remove any temporary development/staging resources
        *   Clean up unused environment variables and secrets
        *   Optimize resource allocation and cost management
        *   Remove development-only monitoring and debugging tools
    2.  **Security Hardening:**
        *   Final security review of all production configurations
        *   Validate all secrets and API keys are properly secured
        *   Review and tighten access permissions and policies
        *   Conduct final vulnerability scan and penetration testing
    3.  **Performance Optimization:**
        *   Final performance tuning based on production metrics
        *   Optimize database queries and connection pooling
        *   Fine-tune caching and CDN configuration
        *   Validate and optimize monitoring overhead
    4.  **Final Testing and Validation:**
        *   Execute full end-to-end test suite in production
        *   Validate all success metrics are being met
        *   Confirm monitoring and alerting systems are fully functional
        *   Test disaster recovery and rollback procedures
    5.  **Production Readiness Checklist:**
        *   All deployment verification tests passing
        *   Performance metrics meeting success criteria
        *   Security measures active and validated
        *   Monitoring and alerting functional
        *   Documentation complete and current
        *   Incident response procedures in place
*   **Validation:**
    *   Infrastructure cleaned and optimized for production use
    *   Security measures hardened and validated
    *   Performance optimized and meeting all success criteria
    *   All final testing completed successfully
    *   Production readiness checklist 100% complete
    *   Application fully functional and ready for user access
*   **Risks:**
    *   Final optimizations might introduce unexpected issues or regressions
    *   Security hardening might break existing functionality
    *   Performance tuning might have unintended consequences
*   **Core Document Updates:** Final validation that all core documents are accurate and current.
*   **Progress:** Not Started
